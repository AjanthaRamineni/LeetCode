//O(E+VlogV) time and O(V+E) space
class Solution {
    
    class Cell {
        int u;
        double p;
        public Cell(int u, double p) {
            this.u = u;
            this.p = p;
        }
    }
    
    Map<Integer, Map<Integer, Double>> adjlist;
    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {
        construct(n, edges, succProb);
        return dijkstras(start, end);
    }
    
    public void construct(int n, int[][] edges, double[] succProb) {
        adjlist = new HashMap();
        int index = 0;
        for(int i=0;i<n;i++) {
            adjlist.put(i, new HashMap());
        }
        for(int[] edge:edges) {
            int u = edge[0], v = edge[1];
            double w = succProb[index++];
            adjlist.get(u).put(v, w);
            adjlist.get(v).put(u,w);
        }
    }
    
    public double dijkstras(int start, int end) {
        Map<Integer, Double> pMap = new HashMap();
        PriorityQueue<Cell> pq = new PriorityQueue(1, new Comparator<Cell>(){
            public int compare(Cell a, Cell b) {
                return Double.compare(b.p, a.p);
            }
        });
        pq.offer(new Cell(start, 1.0));
        while(!pq.isEmpty()) {
            Cell cell = pq.poll();
            int u = cell.u;
            double p = cell.p;
            if(pMap.containsKey(u)) continue;
            pMap.put(u, p);
            if(u==end) return p;
            Map<Integer, Double> map = adjlist.get(u);
            for(Integer v:map.keySet()) {
                if(pMap.containsKey(v)) continue;
                double uvp = map.get(v);
                pq.offer(new Cell(v, p*uvp));
            }
        }
        return 0.0;
    }
    
}
