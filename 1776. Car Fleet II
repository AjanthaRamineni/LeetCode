// O(n) space and time
class Solution {
    public double[] getCollisionTimes(int[][] cars) {
        if(cars == null || cars.length == 0)
            return new double[0];
        
        int n = cars.length;
        double[] res = new double[n];
        Stack<Integer> stack = new Stack();
        
        for(int i=n-1; i>=0; i--)
        {
            res[i] = -1;
//             If speed of current car < next car we dont meet the next car anytime
//             If c1,c2,c3 are cars, if c2 meets c3 before c1 meets c3 we need to compare the
//              time between c1 and c3 ignoring c2
            while(!stack.isEmpty() && canIgnoreCar(res, cars, stack.peek(), i))
            {
                stack.pop();
            }
            if(!stack.isEmpty())
            {
                res[i] = calTime(cars, stack.peek(), i);
            }
            stack.push(i);
        }
        return res;
    }
    
    public boolean canIgnoreCar(double[] res, int[][] cars, int idx, int i)
    {
        boolean isSlowCar = cars[i][1] <= cars[idx][1];
        boolean alreadyCollided = (res[idx] != -1) && (calTime(cars, idx, i) > res[idx]);
        return isSlowCar || alreadyCollided;
    }
    
    public double calTime(int[][] cars, int idx, int i)
    {
        int netDist = cars[idx][0] - cars[i][0];
        int netSpeed = cars[i][1] - cars[idx][1];
        return (double)(netDist/ (double)netSpeed);
    }
}
