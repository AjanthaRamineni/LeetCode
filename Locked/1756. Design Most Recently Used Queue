/*
Design a queue-like data structure that moves the most recently used element to the end of the queue.

Implement the MRUQueue class:

MRUQueue(int n) constructs the MRUQueue with n elements: [1,2,3,...,n].
fetch(int k) moves the kth element (1-indexed) to the end of the queue and returns it.
 

Example 1:

Input:
["MRUQueue", "fetch", "fetch", "fetch", "fetch"]
[[8], [3], [5], [2], [8]]
Output:
[null, 3, 6, 2, 2]

Explanation:
MRUQueue mRUQueue = new MRUQueue(8); // Initializes the queue to [1,2,3,4,5,6,7,8].
mRUQueue.fetch(3); // Moves the 3rd element (3) to the end of the queue to become [1,2,4,5,6,7,8,3] and returns it.
mRUQueue.fetch(5); // Moves the 5th element (6) to the end of the queue to become [1,2,4,5,7,8,3,6] and returns it.
mRUQueue.fetch(2); // Moves the 2nd element (2) to the end of the queue to become [1,4,5,7,8,3,6,2] and returns it.
mRUQueue.fetch(8); // The 8th element (2) is already at the end of the queue so just return it.
*/

//O(sqrt(n)) for MruQueue and Find
class MRUQueue {

    class Node {
        Node pre, post;
        int val;
        
        Node(int val)
        {
            this.val = val;
        }
    }
    
    class Bucket {
        Node head, tail;
        Bucket(int val)
        {
            this.head = new Node(val);
            this.tail = new Node(val);
            head.post = tail;
            tail.pre = head;
        }
        
        public void append(Node node)
        {
            Node pre = tail.pre;
//             Add pointers for node
            node.pre = pre;
            node.post = tail;
//             Adjust remaining pointers 
            tail.pre = node;
            pre.post = node;
        }
        
        public void remove(Node node)
        {
            Node pre = node.pre;
            Node post = node.post;
            pre.post = post;
            post.pre = pre;
        }
        
        public Node findInList(int nodeIdx)
        {
            Node node = head.post;
            for(int i=0; i<nodeIdx; i++)
            {
                node = node.post;
            }
            return node;
        }
    }
    
    Bucket[] buckets;
    int bucketSize;
    
    public MRUQueue(int n) {
        bucketSize = (int)Math.sqrt(n);
        buckets = new Bucket[(n+bucketSize-1)/bucketSize];
        for(int i=0; i<n; i++)
        {
           if(buckets[i/bucketSize] == null)
           {
               buckets[i/bucketSize] = new Bucket(-1);
           }
            buckets[i/bucketSize].append(new Node(i+1));
        }
    }
    
    public int fetch(int k) {
        int kIdx = k-1;
        int bucketIdx = kIdx/bucketSize;
        
        Node res = buckets[bucketIdx].findInList(kIdx%bucketSize);
        buckets[bucketIdx].remove(res);
        
        for(int i=1+kIdx/bucketSize; i<buckets.length; i++)
        {
            Node changedNode = buckets[i].head.post;
            buckets[i].remove(changedNode);
            buckets[i-1].append(changedNode);
        }
        buckets[buckets.length-1].append(res);
        return res.val;
    }
}

/**
 * Your MRUQueue object will be instantiated and called as such:
 * MRUQueue obj = new MRUQueue(n);
 * int param_1 = obj.fetch(k);
 */
