/*

You need to construct a binary tree from a string consisting of parenthesis and integers.

The whole input represents a binary tree. It contains an integer followed by zero, one or two pairs of parenthesis. The integer represents the root's value and a pair of parenthesis contains a child binary tree with the same structure.

You always start to construct the left child node of the parent first if it exists.

There will only be '(', ')', '-' and '0' ~ '9' in the input string.
An empty tree is represented by "" instead of "()".
Have you met this question in a real interview?  
Example
Example 1:

Input: "-4(2(3)(1))(6(5))"
Output: {-4,2,6,3,1,5}
Explanation:
The output is look like this:
      -4
     /  \
    2    6
   / \   / 
  3   1 5   
Example 2:

Input: "1(-1)"
Output: {1,-1}
Explanation:
The output is look like this:
     1
    /
  -1
  
https://www.lintcode.com/problem/construct-binary-tree-from-string/description
  
*/

//O(n) time and space
class Solution {
    public TreeNode str2tree(String s) {
        if(s==null || s.length()==0) return null;
        Stack<TreeNode> stack = new Stack();
        int val = 0, sign = 1;
        int n = s.length();
        for(int i=0;i<s.length()+1;i++) {
            char c = i<s.length()?s.charAt(i):'(';
            if(Character.isDigit(c)) {
                val = val*10 + c-'0';
            }
            else if(c=='-') {
                sign = -1;
            }
            else if(c=='(') {
                if(i>=1 && s.charAt(i-1)!=')') {
                    stack.push(new TreeNode(val*sign));
                }
                val = 0;
                sign = 1;
            }
            else if(c==')') {
                TreeNode child = null;
                if(s.charAt(i-1)!=')') {
                    child = new TreeNode(val*sign);
                    sign = 1;
                }
                else {
                    child = stack.pop();
                }
                TreeNode parent = stack.peek();
                if(parent.left==null) {
                    parent.left = child;
                }
                else {
                    parent.right = child;
                }
            }
        }
        return stack.pop();
    }
}
